#!/usr/bin/env python
from __future__ import print_function
import os, asyncore, socket, struct, ctypes, array, re, errno, argparse, time
import stat, sys
from collections import namedtuple
from sendmsg import recvmsg, SCM_RIGHTS, SCM_CREDENTIALS
from datetime import datetime

Cred = namedtuple("Cred", "pid uid gid")
Metadata = namedtuple("Metadata", "time pid comm unit")

def is_a_socket(fd):
    """tests if the given file descriptor is a socket"""
    return stat.S_ISSOCK(os.fstat(fd).st_mode)

def slurp(path):
    """Read the contents of a file, stripping leading and trailing whitespace."""
    with open(path) as f:
        return f.read().strip()

def parse_ancdata(ancdata):
    """Parse unix socket ancilliary data that was received by recvmsg. Returns
    (fds, cred) where fds is a list of received file descriptors and cred is
    the sending processes' pid, uid and gid.  Either or both may be None.
    """
    fds = None
    cred = None
    for level, type_, value in ancdata:
        if level == socket.SOL_SOCKET:
            if type_ == SCM_RIGHTS:
                fds = array.array('i', value)
            elif type_ == SCM_CREDENTIALS:
                cred = Cred(*struct.unpack('3i', value))
    return fds, cred

def comm_for_pid(pid):
    """Retrieve the process name for a given process id."""
    try:
        return slurp('/proc/%d/comm' % pid)
    except IOError:
        return None

def unit_for_pid(pid):
    """Work out the systemd unit for a process by reading its cgroup."""
    try:
        cgroup = slurp('/proc/%d/cgroup' % pid)
        match = re.search("1:name=systemd:/system.slice/(?:jvm:)?(.+?).service", cgroup)
        return match.group(1) if match else None
    except IOError:
        return None

def format_prefix(meta):
    """Format log metadata as a prefix to be prepended to log lines."""
    ts = meta.time.strftime('%H:%M:%S.%f')[:-3]
    return "%s %s[%d]: " % (ts, meta.comm, meta.pid)

def getpeercred(sock):
    """Returns the pid, uid and gid of the other end of a socket."""
    data = sock.getsockopt(socket.SOL_SOCKET, socket.SO_PEERCRED,
            struct.calcsize('3i'))
    return Cred(*struct.unpack('3i', data))

class LogWriter:
    """A date rotated log file"""

    def __init__(self, logdir, unit, logname):
        self.unit = unit
        self.file = None
        self.path = None
        self.start_of_line = True
        self.template = "{logdir}/{unit}/%Y%m/{logname}.%Y-%m-%d.log".format(
                logdir=logdir, unit=unit, logname=logname)
        self.link_path = "{logdir}/{unit}/{logname}.log".format(
                logdir=logdir, unit=unit, logname=logname)
        self.last_active = time.time()

    def open_file(self, now):
        """(Re)open the log file, creating parent directories as needed."""
        path = now.strftime(self.template)
        if path != self.path:
            if self.file is not None:
                self.file.close()
            self.path = path
            try:
                self.file = open(path, 'a', 0)
            except IOError, e:
                if e.errno == errno.ENOENT:
                    os.makedirs(os.path.dirname(path))
                    self.file = open(path, 'a', 0)

            self.update_link()

    def update_link(self):
        """Create or update a symlink to point at the latest rotation."""
        try:
            os.symlink(self.path, self.link_path)
        except OSError, e:
            if e.errno == errno.EEXIST:
                os.unlink(self.link_path)
                os.symlink(self.path, self.link_path)

    def write(self, data, meta):
        """Write a string to the logfile, prefixing new lines with metadata."""
        self.last_active = time.time()
        self.open_file(now=meta.time)
        prefix = format_prefix(meta)

        if self.start_of_line:
            print(prefix, end="", file=self.file)

        if data.endswith("\n"):
            print(data[:-1].replace('\n', '\n' + prefix), file=self.file)
            self.start_of_line = True
        else:
            print(data.replace('\n', '\n' + prefix), end="", file=self.file)
            self.start_of_line = False

    def close(self):
        """Close the log file. Note that the next invocation of write() will
        reopen it.
        """
        if self.file is not None:
            self.file.close()
            self.file = None

class LogManager:
    """Tracks open log files"""

    def __init__(self, logdir):
        self.writers = {}
        self.logdir = logdir

    def get(self, unit, logname):
        """Retrieves a LogWriter, creating it if necessary"""
        assert unit is not None
        writer = self.writers.get((unit, logname))
        if writer is None:
            writer = LogWriter(self.logdir, unit, logname)
            self.writers[(unit, logname)] = writer
        return writer

    def close_idle(self, secs):
        """Closes any LogWriters which have been idle for the given time"""
        now = time.time()
        for key, writer in self.writers.items():
            if writer.last_active + secs < now:
                del self.writers[key]
                writer.close()

class Handler(asyncore.dispatcher):
    """Handles incoming log messages from applications."""
    start_of_line = True

    def __init__(self, sock, log_manager):
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_PASSCRED, 1)
        asyncore.dispatcher.__init__(self, sock)
        self.log_manager = log_manager
        cred = getpeercred(sock)
        self.unit = unit_for_pid(cred.pid)

    def writable(self):
        """Prevent asyncore for waking up constantly: we never need to write"""
        return False

    def handle_read(self):
        """Called when data is available for reading."""
        data, ancdata, _, _ = recvmsg(self.socket, 65536, 4096)

        if not data:
            return self.handle_close()

        fds, cred = parse_ancdata(ancdata)

        meta = Metadata(time=datetime.now(), pid=cred.pid,
            comm=(comm_for_pid(cred.pid) or "unknown"),
            unit=(unit_for_pid(cred.pid) or self.unit))

        if meta.unit is not None:
            log = self.log_manager.get(meta.unit, "stdio")
            log.write(data, meta)

class Server(asyncore.dispatcher):
    """Listens for new logduct connections and accepts them."""
    def __init__(self, sock, log_manager):
        if isinstance(sock, str):
            asyncore.dispatcher.__init__(self)
            self.create_socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.bind(sock)
            self.listen(5)
        else:
            asyncore.dispatcher.__init__(self, sock)
        self.log_manager = log_manager

    def handle_accept(self):
        """Called when new connections are incoming. Accepts them and creates
        a handler for them."""
        pair = self.accept()
        if pair is not None:
            sock, addr = pair
            Handler(sock, self.log_manager)

def parse_arguments():
    parser = argparse.ArgumentParser(
            description="Listens on a unix socket for application log messages and writes them to a rotated file.",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-s", "--socket", default="/run/logduct.sock", help="unix socket to listen on")
    parser.add_argument("-d", "--logdir", default="/logs", help="directory to write logs under")
    parser.add_argument("--idle", default=60, metavar='SECS', type=float, help="seconds after which idle log files will be closed")
    return parser.parse_args()

def main():
    args = parse_arguments()
    log_manager = LogManager(args.logdir)

    if is_a_socket(sys.stdin.fileno()):
        sock = socket.fromfd(sys.stdin.fileno(), socket.AF_UNIX, socket.SOCK_STREAM)
    else:
        sock = args.socket
    
    server = Server(sock, log_manager)

    next_idle_check = 0
    while True:
        asyncore.loop(timeout=args.idle, count=1)
        now = time.time()
        if now > next_idle_check:
            log_manager.close_idle(args.idle)
            next_idle_check = now + args.idle

if __name__ == '__main__': main()
